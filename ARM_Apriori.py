# Association Rule Mining via Apriori Algorithm
# Data Mining and Warehousing [CS-2376] | Spring 2021 | Ashoka University
# Group 'BSOD' : Rishabh Goswami, Mohammed Zahir Ali, Shreyash Naman

#import required libraries
import csv
import itertools
import matplotlib.pyplot as plt

def dataImport(datapath):
  opendataset = open(datapath, 'r')
  #Read the csv
  readingCSV = csv.reader(opendataset, delimiter=',')

  #Store csv in list form
  dataframe = list(readingCSV)
  return dataframe

def one_itemset(df,minimum_support):
    #Create a list for all 1-itemsets with frequency   
    print('------------ Creating Candidate Set ----------------- \n')
    print(f'Number of transactions (rows) in the Dataset:  {len(df)} \n')

    #initialise empty dictionary to count frequency of item occurence
    C1_itemset = {}

    #loop through the items in data 
    for rows in df:
        for item in rows:
            if item not in C1_itemset: #if item encountered first time
                C1_itemset[(item)] = 1
            else: #if previously encountered, increment
                C1_itemset[(item)] += 1

    #To Print all 1-itemsets
    #print(f'C1 Items: {C1_itemset}')

    #Number of items in Candidate Set 1, i.e. number of unique items in the database
    print(f'Candidate Set 1 (C1) Itemsets :  {len(C1_itemset)} \n')

    #Pruning - Remove itemsets that do not meet the minimum support
    #if frequency of items meets the set support percent, then store that item in another list which is to be used further
    #L1 generated by pruning C1
    L1_itemset = {key: item for key, item in C1_itemset.items() if item >= minimum_support*len(df)} #multiply with dataset rows to get absolute minimum support

    #To print all items in C1 that meet minimum support, or essentially L1
    #print(f'L1 Items : {L1_itemset}')
    
    #Number of itemsets in L1
    print(f'Itemsets in L1 (Frequent itemsets from C1) : {len(L1_itemset)} \n')

    return L1_itemset, df


def gencandidateRunOnce(Ck_from_Lk1, cand_k, df):
    #creating pairs of items (C2 in this case) by making all possible combinations of itemsets from L(k-1) frequent itemsets (or L1 in this case) , for 2-itemsets in Candidate Set C2
    #in this case, we create C2 by making paired combinations from all items in L1

    for first_item in Ck_from_Lk1: 
        for second_item in Ck_from_Lk1:
            if second_item > first_item:
                cand_k.append((first_item, second_item))

    print("------------------------------------------------------")
    print("FOR k = 2 \n")
    print(f'Candidate Set C2 (First 4 itemsets only) : {cand_k[1:5]} ...\n') #only print the first 4 itemsets in the list of all possible 2-itemsets
    print(f'Total itemsets in Candidate Set C2 : {len(cand_k)} \n')

    return Ck_from_Lk1, cand_k


def gencandidateK2(Ck_from_Lk1, cand_k, df):

    for item in Ck_from_Lk1:
      k = len(item) #length of each itemset is k (initially 2 since we have already calculated C2 above)

    #Generating C-k itemset list from L(k-1) frequent set by merging L(k-1) with itself
    #eg - (1,2), (2,3), (3,4), (1,4) -> (1,2,3), (1,3,4), (1,2,4), (2,3,4)

    for first_item in Ck_from_Lk1:
        for second_item in Ck_from_Lk1:
            if (first_item[:-1] == second_item[:-1]) and (first_item[-1] != second_item[-1]): #if all but the last itemset is same
                if first_item[-1] > second_item[-1]: 
                    cand_k.append(second_item + (first_item[-1],))
                else:
                    cand_k.append(first_item + (second_item[-1],))

    print("------------------------------------------------------")
    print(f'FOR k = {str(k+1)} \n')
    print(f'Candidate Set C{str(k+1)} (First 4 itemsets only): {cand_k[1:5]} \n') #print the first 2 items in the k-itemset
    print(f'Total itemsets in Candidate Set C{str(k+1)} : {len(cand_k)} \n')

    return Ck_from_Lk1, cand_k


def gencandidateK(Ck_from_Lk1, boolean, df, minimum_support): #To generate Candidate Set of k-itemsets from L(k-1) itemsets

    #Empty list to store k-itemsets
    cand_k = []
  
    if boolean == True:      
        Ck_from_Lk1, cand_k = gencandidateRunOnce(Ck_from_Lk1, cand_k, df)
        boolean = False


    else: #for C-k beyond k = 2, i.e. C3, C4, C5 etc.
        Ck_from_Lk1, cand_k = gencandidateK2(Ck_from_Lk1, cand_k, df)

    Lset = genL_k(set(cand_k), df, minimum_support) # Made into a set to avoid repetition


    return Lset, boolean


def genL_k(cand_k, df, minimum_support):
    #generate L_k where L is the list of frequent itemsets from C itemsets that meet minimum support criteria

    #If an item in cand_k belongs to a transaction(if those k items were bought together), it is added into another list Ck_freq (thresholded candidate set) which is then pruned (based on support) to form L
    
    Ck_freq = {}
    for itemset in cand_k:
        # To Print all k-item itemsets
        #print(itemset)

        #evaluate the support each item in each itemset in candidate set by comparing it to the transactions (rows) in dataset 
        for rows in df:
            if all(item in rows for item in itemset):
                if itemset not in Ck_freq:
                    Ck_freq[itemset] = 1
                else:
                    Ck_freq[itemset] += 1

    #All items in itemsets that occur in transactions
    print(f'Candidate Set Items : {len(Ck_freq)} \n')

    # Prune Ck for Frequent itemsets that meet minimum support criteria (L_k)
    L_k = {key: item for key, item in Ck_freq.items() if item >= minimum_support*len(df)} #multiply with dataset rows to get absolute minimum support

    # Print frequent itemsets
    print(f'L (frequent itemsets) length: {len(L_k)} \n')
    print(f'L : {(L_k)} \n')

    return L_k



def association_rules(frequent_items,minimum_confidence):

  #Creating association rules for frequent itemsets that meet minimum support
    for itemset in frequent_items.keys(): #for each itemset in the dictionary of all frequent itemsets, make a list of all keys
        if isinstance(itemset, str): #continue if itemset is string 
            continue

        # compute support for each itemset in the list of all frequent items

        support_total = frequent_items[tuple(itemset)]
        
        
        for i in range(1, len(itemset)):

            #make a list of all possible combinations by splitting the itemsets into two - LHS and RHS, with atleast 1 item on each side
            LHS = map(list, itertools.combinations(itemset, i))

            #compute support for each combination and compute confidence
            for items in LHS:
                if len(items) == 1:
                    if ''.join(items) in frequent_items:
                        left_num = frequent_items[''.join(items)]
                        confidence = support_total / left_num
                else:
                    if tuple(items) in frequent_items:
                        left_num = frequent_items[tuple(items)]
                        confidence = support_total / left_num

                #only keep association rules that meet the set minimum confidence level 
                if confidence >= minimum_confidence:
                    
                    RHS = list(itemset[:])
                    for item in items:
                        RHS.remove(item)
                    
                    print(f' {str(items)} -> {str(RHS)} | Confidence: {str(round(confidence,5))} \n')
                    

def main():
    #Importing data and putting it into dataframe
    dataFrame = dataImport('store_data.csv')

    #specify percentages for Minimum Support and Confidence
    minimum_support = 0.01
    minimum_confidence = 0

    oneitem_freq, df = one_itemset(dataFrame, minimum_support)
    boolean = True 
    
    #frequency of items that meet minimum support from a dictionary of all 1-itemsets
    frequency_minsupport = dict(oneitem_freq) 
    while(len(oneitem_freq) != 0):

        oneitem_freq, boolean = gencandidateK(oneitem_freq, boolean, df,minimum_support)
        frequency_minsupport.update(oneitem_freq)
    
    plt.bar(range(len(frequency_minsupport)), list(frequency_minsupport.values()), align='center')

    print("Frequency of items meeting minimum support criteria")
    print("--------------------------------------------------- \n")
    SortedFrequency ={key: item for key, item in sorted(frequency_minsupport.items(),reverse=True, key=lambda item: item[1])}
    print(SortedFrequency, "\n")

    print("Association Rules that meet minimum Confidence")
    print("---------------------------------------------- \n")
    association_rules(frequency_minsupport,minimum_confidence)

    plt.show()


if __name__ == '__main__':
    main()